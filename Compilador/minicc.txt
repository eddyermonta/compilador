Grammar:

Rule 0     S' -> program
Rule 1     program -> decl _1_decl_repeat
Rule 2     _1_decl_repeat -> _1_decl_items
Rule 3     _1_decl_repeat -> <empty>
Rule 4     _1_decl_items -> _1_decl_items _1_decl_item
Rule 5     _1_decl_items -> _1_decl_item
Rule 6     _1_decl_item -> decl
Rule 7     decl -> func_decl
Rule 8     decl -> var_decl
Rule 9     var_decl -> type_spec IDENT [ ] ;
Rule 10    var_decl -> type_spec IDENT ;
Rule 11    type_spec -> FLOAT
Rule 12    type_spec -> INT
Rule 13    type_spec -> BOOL
Rule 14    type_spec -> VOID
Rule 15    func_decl -> type_spec IDENT ( params ) compound_stmt
Rule 16    params -> VOID
Rule 17    params -> param_list
Rule 18    param_list -> param
Rule 19    param_list -> param_list , param
Rule 20    param -> type_spec IDENT [ ]
Rule 21    param -> type_spec IDENT
Rule 22    compound_stmt -> { local_decls stmt_list }
Rule 23    local_decls -> empty
Rule 24    local_decls -> local_decl decl
Rule 25    local_decl -> type_spec IDENT [ ] ;
Rule 26    local_decl -> type_spec IDENT ;
Rule 27    stmt_list -> stmt
Rule 28    stmt_list -> stmt_list stmt
Rule 29    stmt -> break_stmt
Rule 30    stmt -> return_stmt
Rule 31    stmt -> while_stmt
Rule 32    stmt -> if_stmt
Rule 33    stmt -> compound_stmt
Rule 34    stmt -> expr_stmt
Rule 35    expr_stmt -> ;
Rule 36    expr_stmt -> expr ;
Rule 37    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 38    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 39    while_stmt -> WHILE ( expr ) stmt
Rule 40    return_stmt -> RETURN _2_expr_optional ;
Rule 41    _2_expr_optional -> expr
Rule 42    _2_expr_optional -> <empty>
Rule 43    break_stmt -> CONTINUE ;
Rule 44    break_stmt -> BREAK ;
Rule 45    expr -> NEW type_spec [ expr ]
Rule 46    expr -> STRING
Rule 47    expr -> FLOAT_LIT
Rule 48    expr -> INT_LIT
Rule 49    expr -> BOOL_LIT
Rule 50    expr -> IDENT . SIZE
Rule 51    expr -> IDENT ( args )
Rule 52    expr -> IDENT [ expr ]
Rule 53    expr -> IDENT
Rule 54    expr -> ( expr )
Rule 55    expr -> + expr  [precedence=right, level=10]
Rule 56    expr -> - expr  [precedence=right, level=10]
Rule 57    expr -> ! expr  [precedence=right, level=10]
Rule 58    expr -> expr % expr  [precedence=left, level=9]
Rule 59    expr -> expr / expr  [precedence=left, level=9]
Rule 60    expr -> expr * expr  [precedence=left, level=9]
Rule 61    expr -> expr - expr  [precedence=left, level=8]
Rule 62    expr -> expr + expr  [precedence=left, level=8]
Rule 63    expr -> expr > expr  [precedence=left, level=7]
Rule 64    expr -> expr < expr  [precedence=left, level=7]
Rule 65    expr -> expr LE expr  [precedence=left, level=7]
Rule 66    expr -> expr GE expr  [precedence=left, level=7]
Rule 67    expr -> expr NE expr  [precedence=left, level=6]
Rule 68    expr -> expr EQ expr  [precedence=left, level=6]
Rule 69    expr -> expr AND expr  [precedence=left, level=5]
Rule 70    expr -> expr OR expr  [precedence=left, level=4]
Rule 71    expr -> IDENT [ expr ] = expr  [precedence=right, level=3]
Rule 72    expr -> IDENT = expr  [precedence=right, level=3]
Rule 73    args -> empty
Rule 74    args -> arg_list
Rule 75    arg_list -> expr
Rule 76    arg_list -> arg_list , expr
Rule 77    empty -> <empty>

Terminals, with rules where they appear:

!                    : 57
%                    : 58
(                    : 15 37 38 39 51 54
)                    : 15 37 38 39 51 54
*                    : 60
+                    : 55 62
,                    : 19 76
-                    : 56 61
.                    : 50
/                    : 59
;                    : 9 10 25 26 35 36 40 43 44
<                    : 64
=                    : 71 72
>                    : 63
AND                  : 69
BOOL                 : 13
BOOL_LIT             : 49
BREAK                : 44
CONTINUE             : 43
ELSE                 : 38
EQ                   : 68
FLOAT                : 11
FLOAT_LIT            : 47
GE                   : 66
IDENT                : 9 10 15 20 21 25 26 50 51 52 53 71 72
IF                   : 37 38
INT                  : 12
INT_LIT              : 48
LE                   : 65
NE                   : 67
NEW                  : 45
OR                   : 70
RETURN               : 40
SIZE                 : 50
STRING               : 46
VOID                 : 14 16
WHILE                : 39
[                    : 9 20 25 45 52 71
]                    : 9 20 25 45 52 71
error                : 
{                    : 22
}                    : 22

Nonterminals, with rules where they appear:

_1_decl_item         : 4 5
_1_decl_items        : 2 4
_1_decl_repeat       : 1
_2_expr_optional     : 40
arg_list             : 74 76
args                 : 51
break_stmt           : 29
compound_stmt        : 15 33
decl                 : 1 6 24
empty                : 23 73
expr                 : 36 37 38 39 41 45 52 54 55 56 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 75 76
expr_stmt            : 34
func_decl            : 7
if_stmt              : 32
local_decl           : 24
local_decls          : 22
param                : 18 19
param_list           : 17 19
params               : 15
program              : 0
return_stmt          : 30
stmt                 : 27 28 37 38 38 39
stmt_list            : 22 28
type_spec            : 9 10 15 20 21 25 26 45
var_decl             : 8
while_stmt           : 31


state 0

    (0) S' -> . program
    (1) program -> . decl _1_decl_repeat
    (7) decl -> . func_decl
    (8) decl -> . var_decl
    (15) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (9) var_decl -> . type_spec IDENT [ ] ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    program                        shift and go to state 1
    decl                           shift and go to state 2
    func_decl                      shift and go to state 3
    var_decl                       shift and go to state 4
    type_spec                      shift and go to state 5

state 1

    (0) S' -> program .


state 2

    (1) program -> decl . _1_decl_repeat
    (2) _1_decl_repeat -> . _1_decl_items
    (3) _1_decl_repeat -> .
    (4) _1_decl_items -> . _1_decl_items _1_decl_item
    (5) _1_decl_items -> . _1_decl_item
    (6) _1_decl_item -> . decl
    (7) decl -> . func_decl
    (8) decl -> . var_decl
    (15) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (9) var_decl -> . type_spec IDENT [ ] ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    $end            reduce using rule 3 (_1_decl_repeat -> .)
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    decl                           shift and go to state 10
    _1_decl_repeat                 shift and go to state 11
    _1_decl_items                  shift and go to state 12
    _1_decl_item                   shift and go to state 13
    func_decl                      shift and go to state 3
    var_decl                       shift and go to state 4
    type_spec                      shift and go to state 5

state 3

    (7) decl -> func_decl .
    FLOAT           reduce using rule 7 (decl -> func_decl .)
    INT             reduce using rule 7 (decl -> func_decl .)
    BOOL            reduce using rule 7 (decl -> func_decl .)
    VOID            reduce using rule 7 (decl -> func_decl .)
    $end            reduce using rule 7 (decl -> func_decl .)
    CONTINUE        reduce using rule 7 (decl -> func_decl .)
    BREAK           reduce using rule 7 (decl -> func_decl .)
    RETURN          reduce using rule 7 (decl -> func_decl .)
    WHILE           reduce using rule 7 (decl -> func_decl .)
    IF              reduce using rule 7 (decl -> func_decl .)
    {               reduce using rule 7 (decl -> func_decl .)
    ;               reduce using rule 7 (decl -> func_decl .)
    NEW             reduce using rule 7 (decl -> func_decl .)
    STRING          reduce using rule 7 (decl -> func_decl .)
    FLOAT_LIT       reduce using rule 7 (decl -> func_decl .)
    INT_LIT         reduce using rule 7 (decl -> func_decl .)
    BOOL_LIT        reduce using rule 7 (decl -> func_decl .)
    IDENT           reduce using rule 7 (decl -> func_decl .)
    (               reduce using rule 7 (decl -> func_decl .)
    +               reduce using rule 7 (decl -> func_decl .)
    -               reduce using rule 7 (decl -> func_decl .)
    !               reduce using rule 7 (decl -> func_decl .)


state 4

    (8) decl -> var_decl .
    FLOAT           reduce using rule 8 (decl -> var_decl .)
    INT             reduce using rule 8 (decl -> var_decl .)
    BOOL            reduce using rule 8 (decl -> var_decl .)
    VOID            reduce using rule 8 (decl -> var_decl .)
    $end            reduce using rule 8 (decl -> var_decl .)
    CONTINUE        reduce using rule 8 (decl -> var_decl .)
    BREAK           reduce using rule 8 (decl -> var_decl .)
    RETURN          reduce using rule 8 (decl -> var_decl .)
    WHILE           reduce using rule 8 (decl -> var_decl .)
    IF              reduce using rule 8 (decl -> var_decl .)
    {               reduce using rule 8 (decl -> var_decl .)
    ;               reduce using rule 8 (decl -> var_decl .)
    NEW             reduce using rule 8 (decl -> var_decl .)
    STRING          reduce using rule 8 (decl -> var_decl .)
    FLOAT_LIT       reduce using rule 8 (decl -> var_decl .)
    INT_LIT         reduce using rule 8 (decl -> var_decl .)
    BOOL_LIT        reduce using rule 8 (decl -> var_decl .)
    IDENT           reduce using rule 8 (decl -> var_decl .)
    (               reduce using rule 8 (decl -> var_decl .)
    +               reduce using rule 8 (decl -> var_decl .)
    -               reduce using rule 8 (decl -> var_decl .)
    !               reduce using rule 8 (decl -> var_decl .)


state 5

    (15) func_decl -> type_spec . IDENT ( params ) compound_stmt
    (9) var_decl -> type_spec . IDENT [ ] ;
    (10) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 14


state 6

    (11) type_spec -> FLOAT .
    IDENT           reduce using rule 11 (type_spec -> FLOAT .)
    [               reduce using rule 11 (type_spec -> FLOAT .)


state 7

    (12) type_spec -> INT .
    IDENT           reduce using rule 12 (type_spec -> INT .)
    [               reduce using rule 12 (type_spec -> INT .)


state 8

    (13) type_spec -> BOOL .
    IDENT           reduce using rule 13 (type_spec -> BOOL .)
    [               reduce using rule 13 (type_spec -> BOOL .)


state 9

    (14) type_spec -> VOID .
    IDENT           reduce using rule 14 (type_spec -> VOID .)
    [               reduce using rule 14 (type_spec -> VOID .)


state 10

    (6) _1_decl_item -> decl .
    FLOAT           reduce using rule 6 (_1_decl_item -> decl .)
    INT             reduce using rule 6 (_1_decl_item -> decl .)
    BOOL            reduce using rule 6 (_1_decl_item -> decl .)
    VOID            reduce using rule 6 (_1_decl_item -> decl .)
    $end            reduce using rule 6 (_1_decl_item -> decl .)


state 11

    (1) program -> decl _1_decl_repeat .
    $end            reduce using rule 1 (program -> decl _1_decl_repeat .)


state 12

    (2) _1_decl_repeat -> _1_decl_items .
    (4) _1_decl_items -> _1_decl_items . _1_decl_item
    (6) _1_decl_item -> . decl
    (7) decl -> . func_decl
    (8) decl -> . var_decl
    (15) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (9) var_decl -> . type_spec IDENT [ ] ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    $end            reduce using rule 2 (_1_decl_repeat -> _1_decl_items .)
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    _1_decl_item                   shift and go to state 15
    decl                           shift and go to state 10
    func_decl                      shift and go to state 3
    var_decl                       shift and go to state 4
    type_spec                      shift and go to state 5

state 13

    (5) _1_decl_items -> _1_decl_item .
    FLOAT           reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    INT             reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    BOOL            reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    VOID            reduce using rule 5 (_1_decl_items -> _1_decl_item .)
    $end            reduce using rule 5 (_1_decl_items -> _1_decl_item .)


state 14

    (15) func_decl -> type_spec IDENT . ( params ) compound_stmt
    (9) var_decl -> type_spec IDENT . [ ] ;
    (10) var_decl -> type_spec IDENT . ;
    (               shift and go to state 16
    [               shift and go to state 17
    ;               shift and go to state 18


state 15

    (4) _1_decl_items -> _1_decl_items _1_decl_item .
    FLOAT           reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    INT             reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    BOOL            reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    VOID            reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)
    $end            reduce using rule 4 (_1_decl_items -> _1_decl_items _1_decl_item .)


state 16

    (15) func_decl -> type_spec IDENT ( . params ) compound_stmt
    (16) params -> . VOID
    (17) params -> . param_list
    (18) param_list -> . param
    (19) param_list -> . param_list , param
    (20) param -> . type_spec IDENT [ ]
    (21) param -> . type_spec IDENT
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    VOID            shift and go to state 21
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8

    type_spec                      shift and go to state 19
    params                         shift and go to state 20
    param_list                     shift and go to state 22
    param                          shift and go to state 23

state 17

    (9) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 24


state 18

    (10) var_decl -> type_spec IDENT ; .
    FLOAT           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    IF              reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    {               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    ;               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    (               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    +               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    -               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    !               reduce using rule 10 (var_decl -> type_spec IDENT ; .)


state 19

    (20) param -> type_spec . IDENT [ ]
    (21) param -> type_spec . IDENT
    IDENT           shift and go to state 25


state 20

    (15) func_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 26


state 21

    (16) params -> VOID .
    (14) type_spec -> VOID .
    )               reduce using rule 16 (params -> VOID .)
    IDENT           reduce using rule 14 (type_spec -> VOID .)


state 22

    (17) params -> param_list .
    (19) param_list -> param_list . , param
    )               reduce using rule 17 (params -> param_list .)
    ,               shift and go to state 27


state 23

    (18) param_list -> param .
    ,               reduce using rule 18 (param_list -> param .)
    )               reduce using rule 18 (param_list -> param .)


state 24

    (9) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 28


state 25

    (20) param -> type_spec IDENT . [ ]
    (21) param -> type_spec IDENT .
    [               shift and go to state 29
    ,               reduce using rule 21 (param -> type_spec IDENT .)
    )               reduce using rule 21 (param -> type_spec IDENT .)


state 26

    (15) func_decl -> type_spec IDENT ( params ) . compound_stmt
    (22) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 31

    compound_stmt                  shift and go to state 30

state 27

    (19) param_list -> param_list , . param
    (20) param -> . type_spec IDENT [ ]
    (21) param -> . type_spec IDENT
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    param                          shift and go to state 32
    type_spec                      shift and go to state 19

state 28

    (9) var_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    CONTINUE        reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    STRING          reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 9 (var_decl -> type_spec IDENT [ ] ; .)


state 29

    (20) param -> type_spec IDENT [ . ]
    ]               shift and go to state 33


state 30

    (15) func_decl -> type_spec IDENT ( params ) compound_stmt .
    FLOAT           reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    CONTINUE        reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BREAK           reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    RETURN          reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    WHILE           reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    IF              reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    {               reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    ;               reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    NEW             reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    STRING          reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT_LIT       reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT_LIT         reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL_LIT        reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    IDENT           reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    (               reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    +               reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    -               reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    !               reduce using rule 15 (func_decl -> type_spec IDENT ( params ) compound_stmt .)


state 31

    (22) compound_stmt -> { . local_decls stmt_list }
    (23) local_decls -> . empty
    (24) local_decls -> . local_decl decl
    (77) empty -> .
    (25) local_decl -> . type_spec IDENT [ ] ;
    (26) local_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    CONTINUE        reduce using rule 77 (empty -> .)
    BREAK           reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    {               reduce using rule 77 (empty -> .)
    ;               reduce using rule 77 (empty -> .)
    NEW             reduce using rule 77 (empty -> .)
    STRING          reduce using rule 77 (empty -> .)
    FLOAT_LIT       reduce using rule 77 (empty -> .)
    INT_LIT         reduce using rule 77 (empty -> .)
    BOOL_LIT        reduce using rule 77 (empty -> .)
    IDENT           reduce using rule 77 (empty -> .)
    (               reduce using rule 77 (empty -> .)
    +               reduce using rule 77 (empty -> .)
    -               reduce using rule 77 (empty -> .)
    !               reduce using rule 77 (empty -> .)
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    local_decls                    shift and go to state 34
    empty                          shift and go to state 35
    local_decl                     shift and go to state 36
    type_spec                      shift and go to state 37

state 32

    (19) param_list -> param_list , param .
    ,               reduce using rule 19 (param_list -> param_list , param .)
    )               reduce using rule 19 (param_list -> param_list , param .)


state 33

    (20) param -> type_spec IDENT [ ] .
    ,               reduce using rule 20 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 20 (param -> type_spec IDENT [ ] .)


state 34

    (22) compound_stmt -> { local_decls . stmt_list }
    (27) stmt_list -> . stmt
    (28) stmt_list -> . stmt_list stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . while_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . compound_stmt
    (34) stmt -> . expr_stmt
    (43) break_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (40) return_stmt -> . RETURN _2_expr_optional ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (37) if_stmt -> . IF ( expr ) stmt
    (38) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (22) compound_stmt -> . { local_decls stmt_list }
    (35) expr_stmt -> . ;
    (36) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    CONTINUE        shift and go to state 46
    BREAK           shift and go to state 48
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    IF              shift and go to state 53
    {               shift and go to state 31
    ;               shift and go to state 47
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    stmt_list                      shift and go to state 38
    stmt                           shift and go to state 39
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45
    expr                           shift and go to state 52

state 35

    (23) local_decls -> empty .
    CONTINUE        reduce using rule 23 (local_decls -> empty .)
    BREAK           reduce using rule 23 (local_decls -> empty .)
    RETURN          reduce using rule 23 (local_decls -> empty .)
    WHILE           reduce using rule 23 (local_decls -> empty .)
    IF              reduce using rule 23 (local_decls -> empty .)
    {               reduce using rule 23 (local_decls -> empty .)
    ;               reduce using rule 23 (local_decls -> empty .)
    NEW             reduce using rule 23 (local_decls -> empty .)
    STRING          reduce using rule 23 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 23 (local_decls -> empty .)
    INT_LIT         reduce using rule 23 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 23 (local_decls -> empty .)
    IDENT           reduce using rule 23 (local_decls -> empty .)
    (               reduce using rule 23 (local_decls -> empty .)
    +               reduce using rule 23 (local_decls -> empty .)
    -               reduce using rule 23 (local_decls -> empty .)
    !               reduce using rule 23 (local_decls -> empty .)


state 36

    (24) local_decls -> local_decl . decl
    (7) decl -> . func_decl
    (8) decl -> . var_decl
    (15) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (9) var_decl -> . type_spec IDENT [ ] ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    decl                           shift and go to state 63
    func_decl                      shift and go to state 3
    var_decl                       shift and go to state 4
    type_spec                      shift and go to state 5

state 37

    (25) local_decl -> type_spec . IDENT [ ] ;
    (26) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 64


state 38

    (22) compound_stmt -> { local_decls stmt_list . }
    (28) stmt_list -> stmt_list . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . while_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . compound_stmt
    (34) stmt -> . expr_stmt
    (43) break_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (40) return_stmt -> . RETURN _2_expr_optional ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (37) if_stmt -> . IF ( expr ) stmt
    (38) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (22) compound_stmt -> . { local_decls stmt_list }
    (35) expr_stmt -> . ;
    (36) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    }               shift and go to state 65
    CONTINUE        shift and go to state 46
    BREAK           shift and go to state 48
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    IF              shift and go to state 53
    {               shift and go to state 31
    ;               shift and go to state 47
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    stmt                           shift and go to state 66
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45
    expr                           shift and go to state 52

state 39

    (27) stmt_list -> stmt .
    }               reduce using rule 27 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 27 (stmt_list -> stmt .)
    BREAK           reduce using rule 27 (stmt_list -> stmt .)
    RETURN          reduce using rule 27 (stmt_list -> stmt .)
    WHILE           reduce using rule 27 (stmt_list -> stmt .)
    IF              reduce using rule 27 (stmt_list -> stmt .)
    {               reduce using rule 27 (stmt_list -> stmt .)
    ;               reduce using rule 27 (stmt_list -> stmt .)
    NEW             reduce using rule 27 (stmt_list -> stmt .)
    STRING          reduce using rule 27 (stmt_list -> stmt .)
    FLOAT_LIT       reduce using rule 27 (stmt_list -> stmt .)
    INT_LIT         reduce using rule 27 (stmt_list -> stmt .)
    BOOL_LIT        reduce using rule 27 (stmt_list -> stmt .)
    IDENT           reduce using rule 27 (stmt_list -> stmt .)
    (               reduce using rule 27 (stmt_list -> stmt .)
    +               reduce using rule 27 (stmt_list -> stmt .)
    -               reduce using rule 27 (stmt_list -> stmt .)
    !               reduce using rule 27 (stmt_list -> stmt .)


state 40

    (29) stmt -> break_stmt .
    }               reduce using rule 29 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 29 (stmt -> break_stmt .)
    BREAK           reduce using rule 29 (stmt -> break_stmt .)
    RETURN          reduce using rule 29 (stmt -> break_stmt .)
    WHILE           reduce using rule 29 (stmt -> break_stmt .)
    IF              reduce using rule 29 (stmt -> break_stmt .)
    {               reduce using rule 29 (stmt -> break_stmt .)
    ;               reduce using rule 29 (stmt -> break_stmt .)
    NEW             reduce using rule 29 (stmt -> break_stmt .)
    STRING          reduce using rule 29 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 29 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 29 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 29 (stmt -> break_stmt .)
    IDENT           reduce using rule 29 (stmt -> break_stmt .)
    (               reduce using rule 29 (stmt -> break_stmt .)
    +               reduce using rule 29 (stmt -> break_stmt .)
    -               reduce using rule 29 (stmt -> break_stmt .)
    !               reduce using rule 29 (stmt -> break_stmt .)
    ELSE            reduce using rule 29 (stmt -> break_stmt .)


state 41

    (30) stmt -> return_stmt .
    }               reduce using rule 30 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 30 (stmt -> return_stmt .)
    BREAK           reduce using rule 30 (stmt -> return_stmt .)
    RETURN          reduce using rule 30 (stmt -> return_stmt .)
    WHILE           reduce using rule 30 (stmt -> return_stmt .)
    IF              reduce using rule 30 (stmt -> return_stmt .)
    {               reduce using rule 30 (stmt -> return_stmt .)
    ;               reduce using rule 30 (stmt -> return_stmt .)
    NEW             reduce using rule 30 (stmt -> return_stmt .)
    STRING          reduce using rule 30 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 30 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 30 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 30 (stmt -> return_stmt .)
    IDENT           reduce using rule 30 (stmt -> return_stmt .)
    (               reduce using rule 30 (stmt -> return_stmt .)
    +               reduce using rule 30 (stmt -> return_stmt .)
    -               reduce using rule 30 (stmt -> return_stmt .)
    !               reduce using rule 30 (stmt -> return_stmt .)
    ELSE            reduce using rule 30 (stmt -> return_stmt .)


state 42

    (31) stmt -> while_stmt .
    }               reduce using rule 31 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 31 (stmt -> while_stmt .)
    BREAK           reduce using rule 31 (stmt -> while_stmt .)
    RETURN          reduce using rule 31 (stmt -> while_stmt .)
    WHILE           reduce using rule 31 (stmt -> while_stmt .)
    IF              reduce using rule 31 (stmt -> while_stmt .)
    {               reduce using rule 31 (stmt -> while_stmt .)
    ;               reduce using rule 31 (stmt -> while_stmt .)
    NEW             reduce using rule 31 (stmt -> while_stmt .)
    STRING          reduce using rule 31 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 31 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 31 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 31 (stmt -> while_stmt .)
    IDENT           reduce using rule 31 (stmt -> while_stmt .)
    (               reduce using rule 31 (stmt -> while_stmt .)
    +               reduce using rule 31 (stmt -> while_stmt .)
    -               reduce using rule 31 (stmt -> while_stmt .)
    !               reduce using rule 31 (stmt -> while_stmt .)
    ELSE            reduce using rule 31 (stmt -> while_stmt .)


state 43

    (32) stmt -> if_stmt .
    }               reduce using rule 32 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 32 (stmt -> if_stmt .)
    BREAK           reduce using rule 32 (stmt -> if_stmt .)
    RETURN          reduce using rule 32 (stmt -> if_stmt .)
    WHILE           reduce using rule 32 (stmt -> if_stmt .)
    IF              reduce using rule 32 (stmt -> if_stmt .)
    {               reduce using rule 32 (stmt -> if_stmt .)
    ;               reduce using rule 32 (stmt -> if_stmt .)
    NEW             reduce using rule 32 (stmt -> if_stmt .)
    STRING          reduce using rule 32 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 32 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 32 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 32 (stmt -> if_stmt .)
    IDENT           reduce using rule 32 (stmt -> if_stmt .)
    (               reduce using rule 32 (stmt -> if_stmt .)
    +               reduce using rule 32 (stmt -> if_stmt .)
    -               reduce using rule 32 (stmt -> if_stmt .)
    !               reduce using rule 32 (stmt -> if_stmt .)
    ELSE            reduce using rule 32 (stmt -> if_stmt .)


state 44

    (33) stmt -> compound_stmt .
    }               reduce using rule 33 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 33 (stmt -> compound_stmt .)
    BREAK           reduce using rule 33 (stmt -> compound_stmt .)
    RETURN          reduce using rule 33 (stmt -> compound_stmt .)
    WHILE           reduce using rule 33 (stmt -> compound_stmt .)
    IF              reduce using rule 33 (stmt -> compound_stmt .)
    {               reduce using rule 33 (stmt -> compound_stmt .)
    ;               reduce using rule 33 (stmt -> compound_stmt .)
    NEW             reduce using rule 33 (stmt -> compound_stmt .)
    STRING          reduce using rule 33 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 33 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 33 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 33 (stmt -> compound_stmt .)
    IDENT           reduce using rule 33 (stmt -> compound_stmt .)
    (               reduce using rule 33 (stmt -> compound_stmt .)
    +               reduce using rule 33 (stmt -> compound_stmt .)
    -               reduce using rule 33 (stmt -> compound_stmt .)
    !               reduce using rule 33 (stmt -> compound_stmt .)
    ELSE            reduce using rule 33 (stmt -> compound_stmt .)


state 45

    (34) stmt -> expr_stmt .
    }               reduce using rule 34 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 34 (stmt -> expr_stmt .)
    BREAK           reduce using rule 34 (stmt -> expr_stmt .)
    RETURN          reduce using rule 34 (stmt -> expr_stmt .)
    WHILE           reduce using rule 34 (stmt -> expr_stmt .)
    IF              reduce using rule 34 (stmt -> expr_stmt .)
    {               reduce using rule 34 (stmt -> expr_stmt .)
    ;               reduce using rule 34 (stmt -> expr_stmt .)
    NEW             reduce using rule 34 (stmt -> expr_stmt .)
    STRING          reduce using rule 34 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 34 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 34 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 34 (stmt -> expr_stmt .)
    IDENT           reduce using rule 34 (stmt -> expr_stmt .)
    (               reduce using rule 34 (stmt -> expr_stmt .)
    +               reduce using rule 34 (stmt -> expr_stmt .)
    -               reduce using rule 34 (stmt -> expr_stmt .)
    !               reduce using rule 34 (stmt -> expr_stmt .)
    ELSE            reduce using rule 34 (stmt -> expr_stmt .)


state 46

    (43) break_stmt -> CONTINUE . ;
    ;               shift and go to state 67


state 47

    (35) expr_stmt -> ; .
    }               reduce using rule 35 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 35 (expr_stmt -> ; .)
    BREAK           reduce using rule 35 (expr_stmt -> ; .)
    RETURN          reduce using rule 35 (expr_stmt -> ; .)
    WHILE           reduce using rule 35 (expr_stmt -> ; .)
    IF              reduce using rule 35 (expr_stmt -> ; .)
    {               reduce using rule 35 (expr_stmt -> ; .)
    ;               reduce using rule 35 (expr_stmt -> ; .)
    NEW             reduce using rule 35 (expr_stmt -> ; .)
    STRING          reduce using rule 35 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 35 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 35 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 35 (expr_stmt -> ; .)
    IDENT           reduce using rule 35 (expr_stmt -> ; .)
    (               reduce using rule 35 (expr_stmt -> ; .)
    +               reduce using rule 35 (expr_stmt -> ; .)
    -               reduce using rule 35 (expr_stmt -> ; .)
    !               reduce using rule 35 (expr_stmt -> ; .)
    ELSE            reduce using rule 35 (expr_stmt -> ; .)


state 48

    (44) break_stmt -> BREAK . ;
    ;               shift and go to state 68


state 49

    (40) return_stmt -> RETURN . _2_expr_optional ;
    (41) _2_expr_optional -> . expr
    (42) _2_expr_optional -> .
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    ;               reduce using rule 42 (_2_expr_optional -> .)
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    _2_expr_optional               shift and go to state 69
    expr                           shift and go to state 70

state 50

    (39) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 71


state 51

    (54) expr -> ( . expr )
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 72

state 52

    (36) expr_stmt -> expr . ;
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               shift and go to state 73
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 53

    (37) if_stmt -> IF . ( expr ) stmt
    (38) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 87


state 54

    (45) expr -> NEW . type_spec [ expr ]
    (11) type_spec -> . FLOAT
    (12) type_spec -> . INT
    (13) type_spec -> . BOOL
    (14) type_spec -> . VOID
    FLOAT           shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    VOID            shift and go to state 9

    type_spec                      shift and go to state 88

state 55

    (46) expr -> STRING .
    ;               reduce using rule 46 (expr -> STRING .)
    %               reduce using rule 46 (expr -> STRING .)
    /               reduce using rule 46 (expr -> STRING .)
    *               reduce using rule 46 (expr -> STRING .)
    -               reduce using rule 46 (expr -> STRING .)
    +               reduce using rule 46 (expr -> STRING .)
    >               reduce using rule 46 (expr -> STRING .)
    <               reduce using rule 46 (expr -> STRING .)
    LE              reduce using rule 46 (expr -> STRING .)
    GE              reduce using rule 46 (expr -> STRING .)
    NE              reduce using rule 46 (expr -> STRING .)
    EQ              reduce using rule 46 (expr -> STRING .)
    AND             reduce using rule 46 (expr -> STRING .)
    OR              reduce using rule 46 (expr -> STRING .)
    )               reduce using rule 46 (expr -> STRING .)
    ,               reduce using rule 46 (expr -> STRING .)
    ]               reduce using rule 46 (expr -> STRING .)


state 56

    (47) expr -> FLOAT_LIT .
    ;               reduce using rule 47 (expr -> FLOAT_LIT .)
    %               reduce using rule 47 (expr -> FLOAT_LIT .)
    /               reduce using rule 47 (expr -> FLOAT_LIT .)
    *               reduce using rule 47 (expr -> FLOAT_LIT .)
    -               reduce using rule 47 (expr -> FLOAT_LIT .)
    +               reduce using rule 47 (expr -> FLOAT_LIT .)
    >               reduce using rule 47 (expr -> FLOAT_LIT .)
    <               reduce using rule 47 (expr -> FLOAT_LIT .)
    LE              reduce using rule 47 (expr -> FLOAT_LIT .)
    GE              reduce using rule 47 (expr -> FLOAT_LIT .)
    NE              reduce using rule 47 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 47 (expr -> FLOAT_LIT .)
    AND             reduce using rule 47 (expr -> FLOAT_LIT .)
    OR              reduce using rule 47 (expr -> FLOAT_LIT .)
    )               reduce using rule 47 (expr -> FLOAT_LIT .)
    ,               reduce using rule 47 (expr -> FLOAT_LIT .)
    ]               reduce using rule 47 (expr -> FLOAT_LIT .)


state 57

    (48) expr -> INT_LIT .
    ;               reduce using rule 48 (expr -> INT_LIT .)
    %               reduce using rule 48 (expr -> INT_LIT .)
    /               reduce using rule 48 (expr -> INT_LIT .)
    *               reduce using rule 48 (expr -> INT_LIT .)
    -               reduce using rule 48 (expr -> INT_LIT .)
    +               reduce using rule 48 (expr -> INT_LIT .)
    >               reduce using rule 48 (expr -> INT_LIT .)
    <               reduce using rule 48 (expr -> INT_LIT .)
    LE              reduce using rule 48 (expr -> INT_LIT .)
    GE              reduce using rule 48 (expr -> INT_LIT .)
    NE              reduce using rule 48 (expr -> INT_LIT .)
    EQ              reduce using rule 48 (expr -> INT_LIT .)
    AND             reduce using rule 48 (expr -> INT_LIT .)
    OR              reduce using rule 48 (expr -> INT_LIT .)
    )               reduce using rule 48 (expr -> INT_LIT .)
    ,               reduce using rule 48 (expr -> INT_LIT .)
    ]               reduce using rule 48 (expr -> INT_LIT .)


state 58

    (49) expr -> BOOL_LIT .
    ;               reduce using rule 49 (expr -> BOOL_LIT .)
    %               reduce using rule 49 (expr -> BOOL_LIT .)
    /               reduce using rule 49 (expr -> BOOL_LIT .)
    *               reduce using rule 49 (expr -> BOOL_LIT .)
    -               reduce using rule 49 (expr -> BOOL_LIT .)
    +               reduce using rule 49 (expr -> BOOL_LIT .)
    >               reduce using rule 49 (expr -> BOOL_LIT .)
    <               reduce using rule 49 (expr -> BOOL_LIT .)
    LE              reduce using rule 49 (expr -> BOOL_LIT .)
    GE              reduce using rule 49 (expr -> BOOL_LIT .)
    NE              reduce using rule 49 (expr -> BOOL_LIT .)
    EQ              reduce using rule 49 (expr -> BOOL_LIT .)
    AND             reduce using rule 49 (expr -> BOOL_LIT .)
    OR              reduce using rule 49 (expr -> BOOL_LIT .)
    )               reduce using rule 49 (expr -> BOOL_LIT .)
    ,               reduce using rule 49 (expr -> BOOL_LIT .)
    ]               reduce using rule 49 (expr -> BOOL_LIT .)


state 59

    (50) expr -> IDENT . . SIZE
    (51) expr -> IDENT . ( args )
    (52) expr -> IDENT . [ expr ]
    (53) expr -> IDENT .
    (71) expr -> IDENT . [ expr ] = expr
    (72) expr -> IDENT . = expr
    .               shift and go to state 89
    (               shift and go to state 90
    [               shift and go to state 91
    ;               reduce using rule 53 (expr -> IDENT .)
    %               reduce using rule 53 (expr -> IDENT .)
    /               reduce using rule 53 (expr -> IDENT .)
    *               reduce using rule 53 (expr -> IDENT .)
    -               reduce using rule 53 (expr -> IDENT .)
    +               reduce using rule 53 (expr -> IDENT .)
    >               reduce using rule 53 (expr -> IDENT .)
    <               reduce using rule 53 (expr -> IDENT .)
    LE              reduce using rule 53 (expr -> IDENT .)
    GE              reduce using rule 53 (expr -> IDENT .)
    NE              reduce using rule 53 (expr -> IDENT .)
    EQ              reduce using rule 53 (expr -> IDENT .)
    AND             reduce using rule 53 (expr -> IDENT .)
    OR              reduce using rule 53 (expr -> IDENT .)
    )               reduce using rule 53 (expr -> IDENT .)
    ,               reduce using rule 53 (expr -> IDENT .)
    ]               reduce using rule 53 (expr -> IDENT .)
    =               shift and go to state 92


state 60

    (55) expr -> + . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 93

state 61

    (56) expr -> - . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 94

state 62

    (57) expr -> ! . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 95

state 63

    (24) local_decls -> local_decl decl .
    CONTINUE        reduce using rule 24 (local_decls -> local_decl decl .)
    BREAK           reduce using rule 24 (local_decls -> local_decl decl .)
    RETURN          reduce using rule 24 (local_decls -> local_decl decl .)
    WHILE           reduce using rule 24 (local_decls -> local_decl decl .)
    IF              reduce using rule 24 (local_decls -> local_decl decl .)
    {               reduce using rule 24 (local_decls -> local_decl decl .)
    ;               reduce using rule 24 (local_decls -> local_decl decl .)
    NEW             reduce using rule 24 (local_decls -> local_decl decl .)
    STRING          reduce using rule 24 (local_decls -> local_decl decl .)
    FLOAT_LIT       reduce using rule 24 (local_decls -> local_decl decl .)
    INT_LIT         reduce using rule 24 (local_decls -> local_decl decl .)
    BOOL_LIT        reduce using rule 24 (local_decls -> local_decl decl .)
    IDENT           reduce using rule 24 (local_decls -> local_decl decl .)
    (               reduce using rule 24 (local_decls -> local_decl decl .)
    +               reduce using rule 24 (local_decls -> local_decl decl .)
    -               reduce using rule 24 (local_decls -> local_decl decl .)
    !               reduce using rule 24 (local_decls -> local_decl decl .)


state 64

    (25) local_decl -> type_spec IDENT . [ ] ;
    (26) local_decl -> type_spec IDENT . ;
    [               shift and go to state 96
    ;               shift and go to state 97


state 65

    (22) compound_stmt -> { local_decls stmt_list } .
    FLOAT           reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 22 (compound_stmt -> { local_decls stmt_list } .)


state 66

    (28) stmt_list -> stmt_list stmt .
    }               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 28 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 28 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 28 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 28 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 28 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 28 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 28 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 28 (stmt_list -> stmt_list stmt .)


state 67

    (43) break_stmt -> CONTINUE ; .
    }               reduce using rule 43 (break_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 43 (break_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 43 (break_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 43 (break_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 43 (break_stmt -> CONTINUE ; .)
    IF              reduce using rule 43 (break_stmt -> CONTINUE ; .)
    {               reduce using rule 43 (break_stmt -> CONTINUE ; .)
    ;               reduce using rule 43 (break_stmt -> CONTINUE ; .)
    NEW             reduce using rule 43 (break_stmt -> CONTINUE ; .)
    STRING          reduce using rule 43 (break_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 43 (break_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 43 (break_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 43 (break_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 43 (break_stmt -> CONTINUE ; .)
    (               reduce using rule 43 (break_stmt -> CONTINUE ; .)
    +               reduce using rule 43 (break_stmt -> CONTINUE ; .)
    -               reduce using rule 43 (break_stmt -> CONTINUE ; .)
    !               reduce using rule 43 (break_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 43 (break_stmt -> CONTINUE ; .)


state 68

    (44) break_stmt -> BREAK ; .
    }               reduce using rule 44 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 44 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 44 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 44 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 44 (break_stmt -> BREAK ; .)
    IF              reduce using rule 44 (break_stmt -> BREAK ; .)
    {               reduce using rule 44 (break_stmt -> BREAK ; .)
    ;               reduce using rule 44 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 44 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 44 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 44 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 44 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 44 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 44 (break_stmt -> BREAK ; .)
    (               reduce using rule 44 (break_stmt -> BREAK ; .)
    +               reduce using rule 44 (break_stmt -> BREAK ; .)
    -               reduce using rule 44 (break_stmt -> BREAK ; .)
    !               reduce using rule 44 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 44 (break_stmt -> BREAK ; .)


state 69

    (40) return_stmt -> RETURN _2_expr_optional . ;
    ;               shift and go to state 98


state 70

    (41) _2_expr_optional -> expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 41 (_2_expr_optional -> expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 71

    (39) while_stmt -> WHILE ( . expr ) stmt
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 99

state 72

    (54) expr -> ( expr . )
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    )               shift and go to state 100
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 73

    (36) expr_stmt -> expr ; .
    }               reduce using rule 36 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 36 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 36 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 36 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 36 (expr_stmt -> expr ; .)
    IF              reduce using rule 36 (expr_stmt -> expr ; .)
    {               reduce using rule 36 (expr_stmt -> expr ; .)
    ;               reduce using rule 36 (expr_stmt -> expr ; .)
    NEW             reduce using rule 36 (expr_stmt -> expr ; .)
    STRING          reduce using rule 36 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 36 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 36 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 36 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 36 (expr_stmt -> expr ; .)
    (               reduce using rule 36 (expr_stmt -> expr ; .)
    +               reduce using rule 36 (expr_stmt -> expr ; .)
    -               reduce using rule 36 (expr_stmt -> expr ; .)
    !               reduce using rule 36 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 36 (expr_stmt -> expr ; .)


state 74

    (58) expr -> expr % . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 101

state 75

    (59) expr -> expr / . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 102

state 76

    (60) expr -> expr * . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 103

state 77

    (61) expr -> expr - . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 104

state 78

    (62) expr -> expr + . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 105

state 79

    (63) expr -> expr > . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 106

state 80

    (64) expr -> expr < . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 107

state 81

    (65) expr -> expr LE . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 108

state 82

    (66) expr -> expr GE . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 109

state 83

    (67) expr -> expr NE . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 110

state 84

    (68) expr -> expr EQ . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 111

state 85

    (69) expr -> expr AND . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 112

state 86

    (70) expr -> expr OR . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 113

state 87

    (37) if_stmt -> IF ( . expr ) stmt
    (38) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 114

state 88

    (45) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 115


state 89

    (50) expr -> IDENT . . SIZE
    SIZE            shift and go to state 116


state 90

    (51) expr -> IDENT ( . args )
    (73) args -> . empty
    (74) args -> . arg_list
    (77) empty -> .
    (75) arg_list -> . expr
    (76) arg_list -> . arg_list , expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    )               reduce using rule 77 (empty -> .)
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    args                           shift and go to state 117
    empty                          shift and go to state 118
    arg_list                       shift and go to state 119
    expr                           shift and go to state 120

state 91

    (52) expr -> IDENT [ . expr ]
    (71) expr -> IDENT [ . expr ] = expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 121

state 92

    (72) expr -> IDENT = . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 122

state 93

    (55) expr -> + expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 55 (expr -> + expr .)
    %               reduce using rule 55 (expr -> + expr .)
    /               reduce using rule 55 (expr -> + expr .)
    *               reduce using rule 55 (expr -> + expr .)
    -               reduce using rule 55 (expr -> + expr .)
    +               reduce using rule 55 (expr -> + expr .)
    >               reduce using rule 55 (expr -> + expr .)
    <               reduce using rule 55 (expr -> + expr .)
    LE              reduce using rule 55 (expr -> + expr .)
    GE              reduce using rule 55 (expr -> + expr .)
    NE              reduce using rule 55 (expr -> + expr .)
    EQ              reduce using rule 55 (expr -> + expr .)
    AND             reduce using rule 55 (expr -> + expr .)
    OR              reduce using rule 55 (expr -> + expr .)
    )               reduce using rule 55 (expr -> + expr .)
    ,               reduce using rule 55 (expr -> + expr .)
    ]               reduce using rule 55 (expr -> + expr .)


state 94

    (56) expr -> - expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 56 (expr -> - expr .)
    %               reduce using rule 56 (expr -> - expr .)
    /               reduce using rule 56 (expr -> - expr .)
    *               reduce using rule 56 (expr -> - expr .)
    -               reduce using rule 56 (expr -> - expr .)
    +               reduce using rule 56 (expr -> - expr .)
    >               reduce using rule 56 (expr -> - expr .)
    <               reduce using rule 56 (expr -> - expr .)
    LE              reduce using rule 56 (expr -> - expr .)
    GE              reduce using rule 56 (expr -> - expr .)
    NE              reduce using rule 56 (expr -> - expr .)
    EQ              reduce using rule 56 (expr -> - expr .)
    AND             reduce using rule 56 (expr -> - expr .)
    OR              reduce using rule 56 (expr -> - expr .)
    )               reduce using rule 56 (expr -> - expr .)
    ,               reduce using rule 56 (expr -> - expr .)
    ]               reduce using rule 56 (expr -> - expr .)


state 95

    (57) expr -> ! expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 57 (expr -> ! expr .)
    %               reduce using rule 57 (expr -> ! expr .)
    /               reduce using rule 57 (expr -> ! expr .)
    *               reduce using rule 57 (expr -> ! expr .)
    -               reduce using rule 57 (expr -> ! expr .)
    +               reduce using rule 57 (expr -> ! expr .)
    >               reduce using rule 57 (expr -> ! expr .)
    <               reduce using rule 57 (expr -> ! expr .)
    LE              reduce using rule 57 (expr -> ! expr .)
    GE              reduce using rule 57 (expr -> ! expr .)
    NE              reduce using rule 57 (expr -> ! expr .)
    EQ              reduce using rule 57 (expr -> ! expr .)
    AND             reduce using rule 57 (expr -> ! expr .)
    OR              reduce using rule 57 (expr -> ! expr .)
    )               reduce using rule 57 (expr -> ! expr .)
    ,               reduce using rule 57 (expr -> ! expr .)
    ]               reduce using rule 57 (expr -> ! expr .)


state 96

    (25) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 123


state 97

    (26) local_decl -> type_spec IDENT ; .
    FLOAT           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 26 (local_decl -> type_spec IDENT ; .)


state 98

    (40) return_stmt -> RETURN _2_expr_optional ; .
    }               reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    CONTINUE        reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    BREAK           reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    RETURN          reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    WHILE           reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    IF              reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    {               reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    ;               reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    NEW             reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    STRING          reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    FLOAT_LIT       reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    INT_LIT         reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    BOOL_LIT        reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    IDENT           reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    (               reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    +               reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    -               reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    !               reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)
    ELSE            reduce using rule 40 (return_stmt -> RETURN _2_expr_optional ; .)


state 99

    (39) while_stmt -> WHILE ( expr . ) stmt
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    )               shift and go to state 124
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 100

    (54) expr -> ( expr ) .
    ;               reduce using rule 54 (expr -> ( expr ) .)
    %               reduce using rule 54 (expr -> ( expr ) .)
    /               reduce using rule 54 (expr -> ( expr ) .)
    *               reduce using rule 54 (expr -> ( expr ) .)
    -               reduce using rule 54 (expr -> ( expr ) .)
    +               reduce using rule 54 (expr -> ( expr ) .)
    >               reduce using rule 54 (expr -> ( expr ) .)
    <               reduce using rule 54 (expr -> ( expr ) .)
    LE              reduce using rule 54 (expr -> ( expr ) .)
    GE              reduce using rule 54 (expr -> ( expr ) .)
    NE              reduce using rule 54 (expr -> ( expr ) .)
    EQ              reduce using rule 54 (expr -> ( expr ) .)
    AND             reduce using rule 54 (expr -> ( expr ) .)
    OR              reduce using rule 54 (expr -> ( expr ) .)
    )               reduce using rule 54 (expr -> ( expr ) .)
    ,               reduce using rule 54 (expr -> ( expr ) .)
    ]               reduce using rule 54 (expr -> ( expr ) .)


state 101

    (58) expr -> expr % expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 58 (expr -> expr % expr .)
    %               reduce using rule 58 (expr -> expr % expr .)
    /               reduce using rule 58 (expr -> expr % expr .)
    *               reduce using rule 58 (expr -> expr % expr .)
    -               reduce using rule 58 (expr -> expr % expr .)
    +               reduce using rule 58 (expr -> expr % expr .)
    >               reduce using rule 58 (expr -> expr % expr .)
    <               reduce using rule 58 (expr -> expr % expr .)
    LE              reduce using rule 58 (expr -> expr % expr .)
    GE              reduce using rule 58 (expr -> expr % expr .)
    NE              reduce using rule 58 (expr -> expr % expr .)
    EQ              reduce using rule 58 (expr -> expr % expr .)
    AND             reduce using rule 58 (expr -> expr % expr .)
    OR              reduce using rule 58 (expr -> expr % expr .)
    )               reduce using rule 58 (expr -> expr % expr .)
    ,               reduce using rule 58 (expr -> expr % expr .)
    ]               reduce using rule 58 (expr -> expr % expr .)


state 102

    (59) expr -> expr / expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 59 (expr -> expr / expr .)
    %               reduce using rule 59 (expr -> expr / expr .)
    /               reduce using rule 59 (expr -> expr / expr .)
    *               reduce using rule 59 (expr -> expr / expr .)
    -               reduce using rule 59 (expr -> expr / expr .)
    +               reduce using rule 59 (expr -> expr / expr .)
    >               reduce using rule 59 (expr -> expr / expr .)
    <               reduce using rule 59 (expr -> expr / expr .)
    LE              reduce using rule 59 (expr -> expr / expr .)
    GE              reduce using rule 59 (expr -> expr / expr .)
    NE              reduce using rule 59 (expr -> expr / expr .)
    EQ              reduce using rule 59 (expr -> expr / expr .)
    AND             reduce using rule 59 (expr -> expr / expr .)
    OR              reduce using rule 59 (expr -> expr / expr .)
    )               reduce using rule 59 (expr -> expr / expr .)
    ,               reduce using rule 59 (expr -> expr / expr .)
    ]               reduce using rule 59 (expr -> expr / expr .)


state 103

    (60) expr -> expr * expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 60 (expr -> expr * expr .)
    %               reduce using rule 60 (expr -> expr * expr .)
    /               reduce using rule 60 (expr -> expr * expr .)
    *               reduce using rule 60 (expr -> expr * expr .)
    -               reduce using rule 60 (expr -> expr * expr .)
    +               reduce using rule 60 (expr -> expr * expr .)
    >               reduce using rule 60 (expr -> expr * expr .)
    <               reduce using rule 60 (expr -> expr * expr .)
    LE              reduce using rule 60 (expr -> expr * expr .)
    GE              reduce using rule 60 (expr -> expr * expr .)
    NE              reduce using rule 60 (expr -> expr * expr .)
    EQ              reduce using rule 60 (expr -> expr * expr .)
    AND             reduce using rule 60 (expr -> expr * expr .)
    OR              reduce using rule 60 (expr -> expr * expr .)
    )               reduce using rule 60 (expr -> expr * expr .)
    ,               reduce using rule 60 (expr -> expr * expr .)
    ]               reduce using rule 60 (expr -> expr * expr .)


state 104

    (61) expr -> expr - expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 61 (expr -> expr - expr .)
    -               reduce using rule 61 (expr -> expr - expr .)
    +               reduce using rule 61 (expr -> expr - expr .)
    >               reduce using rule 61 (expr -> expr - expr .)
    <               reduce using rule 61 (expr -> expr - expr .)
    LE              reduce using rule 61 (expr -> expr - expr .)
    GE              reduce using rule 61 (expr -> expr - expr .)
    NE              reduce using rule 61 (expr -> expr - expr .)
    EQ              reduce using rule 61 (expr -> expr - expr .)
    AND             reduce using rule 61 (expr -> expr - expr .)
    OR              reduce using rule 61 (expr -> expr - expr .)
    )               reduce using rule 61 (expr -> expr - expr .)
    ,               reduce using rule 61 (expr -> expr - expr .)
    ]               reduce using rule 61 (expr -> expr - expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76


state 105

    (62) expr -> expr + expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 62 (expr -> expr + expr .)
    -               reduce using rule 62 (expr -> expr + expr .)
    +               reduce using rule 62 (expr -> expr + expr .)
    >               reduce using rule 62 (expr -> expr + expr .)
    <               reduce using rule 62 (expr -> expr + expr .)
    LE              reduce using rule 62 (expr -> expr + expr .)
    GE              reduce using rule 62 (expr -> expr + expr .)
    NE              reduce using rule 62 (expr -> expr + expr .)
    EQ              reduce using rule 62 (expr -> expr + expr .)
    AND             reduce using rule 62 (expr -> expr + expr .)
    OR              reduce using rule 62 (expr -> expr + expr .)
    )               reduce using rule 62 (expr -> expr + expr .)
    ,               reduce using rule 62 (expr -> expr + expr .)
    ]               reduce using rule 62 (expr -> expr + expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76


state 106

    (63) expr -> expr > expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> expr > expr .)
    >               reduce using rule 63 (expr -> expr > expr .)
    <               reduce using rule 63 (expr -> expr > expr .)
    LE              reduce using rule 63 (expr -> expr > expr .)
    GE              reduce using rule 63 (expr -> expr > expr .)
    NE              reduce using rule 63 (expr -> expr > expr .)
    EQ              reduce using rule 63 (expr -> expr > expr .)
    AND             reduce using rule 63 (expr -> expr > expr .)
    OR              reduce using rule 63 (expr -> expr > expr .)
    )               reduce using rule 63 (expr -> expr > expr .)
    ,               reduce using rule 63 (expr -> expr > expr .)
    ]               reduce using rule 63 (expr -> expr > expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78


state 107

    (64) expr -> expr < expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> expr < expr .)
    >               reduce using rule 64 (expr -> expr < expr .)
    <               reduce using rule 64 (expr -> expr < expr .)
    LE              reduce using rule 64 (expr -> expr < expr .)
    GE              reduce using rule 64 (expr -> expr < expr .)
    NE              reduce using rule 64 (expr -> expr < expr .)
    EQ              reduce using rule 64 (expr -> expr < expr .)
    AND             reduce using rule 64 (expr -> expr < expr .)
    OR              reduce using rule 64 (expr -> expr < expr .)
    )               reduce using rule 64 (expr -> expr < expr .)
    ,               reduce using rule 64 (expr -> expr < expr .)
    ]               reduce using rule 64 (expr -> expr < expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78


state 108

    (65) expr -> expr LE expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> expr LE expr .)
    >               reduce using rule 65 (expr -> expr LE expr .)
    <               reduce using rule 65 (expr -> expr LE expr .)
    LE              reduce using rule 65 (expr -> expr LE expr .)
    GE              reduce using rule 65 (expr -> expr LE expr .)
    NE              reduce using rule 65 (expr -> expr LE expr .)
    EQ              reduce using rule 65 (expr -> expr LE expr .)
    AND             reduce using rule 65 (expr -> expr LE expr .)
    OR              reduce using rule 65 (expr -> expr LE expr .)
    )               reduce using rule 65 (expr -> expr LE expr .)
    ,               reduce using rule 65 (expr -> expr LE expr .)
    ]               reduce using rule 65 (expr -> expr LE expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78


state 109

    (66) expr -> expr GE expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr GE expr .)
    >               reduce using rule 66 (expr -> expr GE expr .)
    <               reduce using rule 66 (expr -> expr GE expr .)
    LE              reduce using rule 66 (expr -> expr GE expr .)
    GE              reduce using rule 66 (expr -> expr GE expr .)
    NE              reduce using rule 66 (expr -> expr GE expr .)
    EQ              reduce using rule 66 (expr -> expr GE expr .)
    AND             reduce using rule 66 (expr -> expr GE expr .)
    OR              reduce using rule 66 (expr -> expr GE expr .)
    )               reduce using rule 66 (expr -> expr GE expr .)
    ,               reduce using rule 66 (expr -> expr GE expr .)
    ]               reduce using rule 66 (expr -> expr GE expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78


state 110

    (67) expr -> expr NE expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> expr NE expr .)
    NE              reduce using rule 67 (expr -> expr NE expr .)
    EQ              reduce using rule 67 (expr -> expr NE expr .)
    AND             reduce using rule 67 (expr -> expr NE expr .)
    OR              reduce using rule 67 (expr -> expr NE expr .)
    )               reduce using rule 67 (expr -> expr NE expr .)
    ,               reduce using rule 67 (expr -> expr NE expr .)
    ]               reduce using rule 67 (expr -> expr NE expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82


state 111

    (68) expr -> expr EQ expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> expr EQ expr .)
    NE              reduce using rule 68 (expr -> expr EQ expr .)
    EQ              reduce using rule 68 (expr -> expr EQ expr .)
    AND             reduce using rule 68 (expr -> expr EQ expr .)
    OR              reduce using rule 68 (expr -> expr EQ expr .)
    )               reduce using rule 68 (expr -> expr EQ expr .)
    ,               reduce using rule 68 (expr -> expr EQ expr .)
    ]               reduce using rule 68 (expr -> expr EQ expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82


state 112

    (69) expr -> expr AND expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 69 (expr -> expr AND expr .)
    AND             reduce using rule 69 (expr -> expr AND expr .)
    OR              reduce using rule 69 (expr -> expr AND expr .)
    )               reduce using rule 69 (expr -> expr AND expr .)
    ,               reduce using rule 69 (expr -> expr AND expr .)
    ]               reduce using rule 69 (expr -> expr AND expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84


state 113

    (70) expr -> expr OR expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 70 (expr -> expr OR expr .)
    OR              reduce using rule 70 (expr -> expr OR expr .)
    )               reduce using rule 70 (expr -> expr OR expr .)
    ,               reduce using rule 70 (expr -> expr OR expr .)
    ]               reduce using rule 70 (expr -> expr OR expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85


state 114

    (37) if_stmt -> IF ( expr . ) stmt
    (38) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    )               shift and go to state 125
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 115

    (45) expr -> NEW type_spec [ . expr ]
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 126

state 116

    (50) expr -> IDENT . SIZE .
    ;               reduce using rule 50 (expr -> IDENT . SIZE .)
    %               reduce using rule 50 (expr -> IDENT . SIZE .)
    /               reduce using rule 50 (expr -> IDENT . SIZE .)
    *               reduce using rule 50 (expr -> IDENT . SIZE .)
    -               reduce using rule 50 (expr -> IDENT . SIZE .)
    +               reduce using rule 50 (expr -> IDENT . SIZE .)
    >               reduce using rule 50 (expr -> IDENT . SIZE .)
    <               reduce using rule 50 (expr -> IDENT . SIZE .)
    LE              reduce using rule 50 (expr -> IDENT . SIZE .)
    GE              reduce using rule 50 (expr -> IDENT . SIZE .)
    NE              reduce using rule 50 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 50 (expr -> IDENT . SIZE .)
    AND             reduce using rule 50 (expr -> IDENT . SIZE .)
    OR              reduce using rule 50 (expr -> IDENT . SIZE .)
    )               reduce using rule 50 (expr -> IDENT . SIZE .)
    ,               reduce using rule 50 (expr -> IDENT . SIZE .)
    ]               reduce using rule 50 (expr -> IDENT . SIZE .)


state 117

    (51) expr -> IDENT ( args . )
    )               shift and go to state 127


state 118

    (73) args -> empty .
    )               reduce using rule 73 (args -> empty .)


state 119

    (74) args -> arg_list .
    (76) arg_list -> arg_list . , expr
    )               reduce using rule 74 (args -> arg_list .)
    ,               shift and go to state 128


state 120

    (75) arg_list -> expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ,               reduce using rule 75 (arg_list -> expr .)
    )               reduce using rule 75 (arg_list -> expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 121

    (52) expr -> IDENT [ expr . ]
    (71) expr -> IDENT [ expr . ] = expr
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ]               shift and go to state 129
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 122

    (72) expr -> IDENT = expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 72 (expr -> IDENT = expr .)
    )               reduce using rule 72 (expr -> IDENT = expr .)
    ,               reduce using rule 72 (expr -> IDENT = expr .)
    ]               reduce using rule 72 (expr -> IDENT = expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 123

    (25) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 130


state 124

    (39) while_stmt -> WHILE ( expr ) . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . while_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . compound_stmt
    (34) stmt -> . expr_stmt
    (43) break_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (40) return_stmt -> . RETURN _2_expr_optional ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (37) if_stmt -> . IF ( expr ) stmt
    (38) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (22) compound_stmt -> . { local_decls stmt_list }
    (35) expr_stmt -> . ;
    (36) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    CONTINUE        shift and go to state 46
    BREAK           shift and go to state 48
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    IF              shift and go to state 53
    {               shift and go to state 31
    ;               shift and go to state 47
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 52
    stmt                           shift and go to state 131
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45

state 125

    (37) if_stmt -> IF ( expr ) . stmt
    (38) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . while_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . compound_stmt
    (34) stmt -> . expr_stmt
    (43) break_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (40) return_stmt -> . RETURN _2_expr_optional ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (37) if_stmt -> . IF ( expr ) stmt
    (38) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (22) compound_stmt -> . { local_decls stmt_list }
    (35) expr_stmt -> . ;
    (36) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    CONTINUE        shift and go to state 46
    BREAK           shift and go to state 48
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    IF              shift and go to state 53
    {               shift and go to state 31
    ;               shift and go to state 47
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 52
    stmt                           shift and go to state 132
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45

state 126

    (45) expr -> NEW type_spec [ expr . ]
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ]               shift and go to state 133
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 127

    (51) expr -> IDENT ( args ) .
    ;               reduce using rule 51 (expr -> IDENT ( args ) .)
    %               reduce using rule 51 (expr -> IDENT ( args ) .)
    /               reduce using rule 51 (expr -> IDENT ( args ) .)
    *               reduce using rule 51 (expr -> IDENT ( args ) .)
    -               reduce using rule 51 (expr -> IDENT ( args ) .)
    +               reduce using rule 51 (expr -> IDENT ( args ) .)
    >               reduce using rule 51 (expr -> IDENT ( args ) .)
    <               reduce using rule 51 (expr -> IDENT ( args ) .)
    LE              reduce using rule 51 (expr -> IDENT ( args ) .)
    GE              reduce using rule 51 (expr -> IDENT ( args ) .)
    NE              reduce using rule 51 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 51 (expr -> IDENT ( args ) .)
    AND             reduce using rule 51 (expr -> IDENT ( args ) .)
    OR              reduce using rule 51 (expr -> IDENT ( args ) .)
    )               reduce using rule 51 (expr -> IDENT ( args ) .)
    ,               reduce using rule 51 (expr -> IDENT ( args ) .)
    ]               reduce using rule 51 (expr -> IDENT ( args ) .)


state 128

    (76) arg_list -> arg_list , . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 134

state 129

    (52) expr -> IDENT [ expr ] .
    (71) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 52 (expr -> IDENT [ expr ] .)
    %               reduce using rule 52 (expr -> IDENT [ expr ] .)
    /               reduce using rule 52 (expr -> IDENT [ expr ] .)
    *               reduce using rule 52 (expr -> IDENT [ expr ] .)
    -               reduce using rule 52 (expr -> IDENT [ expr ] .)
    +               reduce using rule 52 (expr -> IDENT [ expr ] .)
    >               reduce using rule 52 (expr -> IDENT [ expr ] .)
    <               reduce using rule 52 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 52 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 52 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 52 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 52 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 52 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 52 (expr -> IDENT [ expr ] .)
    )               reduce using rule 52 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 52 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 52 (expr -> IDENT [ expr ] .)
    =               shift and go to state 135


state 130

    (25) local_decl -> type_spec IDENT [ ] ; .
    FLOAT           reduce using rule 25 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 25 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 25 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 25 (local_decl -> type_spec IDENT [ ] ; .)


state 131

    (39) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)


state 132

    (37) if_stmt -> IF ( expr ) stmt .
    (38) if_stmt -> IF ( expr ) stmt . ELSE stmt
    }               reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 37 (if_stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 136


state 133

    (45) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)


state 134

    (76) arg_list -> arg_list , expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ,               reduce using rule 76 (arg_list -> arg_list , expr .)
    )               reduce using rule 76 (arg_list -> arg_list , expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 135

    (71) expr -> IDENT [ expr ] = . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 137

state 136

    (38) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . while_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . compound_stmt
    (34) stmt -> . expr_stmt
    (43) break_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (40) return_stmt -> . RETURN _2_expr_optional ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (37) if_stmt -> . IF ( expr ) stmt
    (38) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (22) compound_stmt -> . { local_decls stmt_list }
    (35) expr_stmt -> . ;
    (36) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING
    (47) expr -> . FLOAT_LIT
    (48) expr -> . INT_LIT
    (49) expr -> . BOOL_LIT
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . IDENT [ expr ]
    (53) expr -> . IDENT
    (54) expr -> . ( expr )
    (55) expr -> . + expr
    (56) expr -> . - expr
    (57) expr -> . ! expr
    (58) expr -> . expr % expr
    (59) expr -> . expr / expr
    (60) expr -> . expr * expr
    (61) expr -> . expr - expr
    (62) expr -> . expr + expr
    (63) expr -> . expr > expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr NE expr
    (68) expr -> . expr EQ expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr OR expr
    (71) expr -> . IDENT [ expr ] = expr
    (72) expr -> . IDENT = expr
    CONTINUE        shift and go to state 46
    BREAK           shift and go to state 48
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    IF              shift and go to state 53
    {               shift and go to state 31
    ;               shift and go to state 47
    NEW             shift and go to state 54
    STRING          shift and go to state 55
    FLOAT_LIT       shift and go to state 56
    INT_LIT         shift and go to state 57
    BOOL_LIT        shift and go to state 58
    IDENT           shift and go to state 59
    (               shift and go to state 51
    +               shift and go to state 60
    -               shift and go to state 61
    !               shift and go to state 62

    expr                           shift and go to state 52
    stmt                           shift and go to state 138
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45

state 137

    (71) expr -> IDENT [ expr ] = expr .
    (58) expr -> expr . % expr
    (59) expr -> expr . / expr
    (60) expr -> expr . * expr
    (61) expr -> expr . - expr
    (62) expr -> expr . + expr
    (63) expr -> expr . > expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . NE expr
    (68) expr -> expr . EQ expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . OR expr
    ;               reduce using rule 71 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 71 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 71 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 71 (expr -> IDENT [ expr ] = expr .)
    %               shift and go to state 74
    /               shift and go to state 75
    *               shift and go to state 76
    -               shift and go to state 77
    +               shift and go to state 78
    >               shift and go to state 79
    <               shift and go to state 80
    LE              shift and go to state 81
    GE              shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 138

    (38) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 38 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
